### 设计模式的七大原则：

* 单一职责原则(Single Responsibility Principle)：对类来说的，即一个类应该只负责一项职责。

* 接口隔离原则(Interface Segregation Principle)： 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。

* 依赖倒转原则(Dependence Inversion Principle)：

  * 高层模块不应该依赖底层模块，二者都应该依赖其抽象
  * 抽象不应该依赖细节，细节应该依赖抽象
  * 依赖倒转（倒置）的中心思想是面向接口编程
  * 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建比以细节为基础的架构要稳定的多，在java中，抽象指的是接口或者抽象类，细节就是具体的实现类
  * 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的实现，把展现细节的任务交给他们的实现类去做。

  依赖关系传递的三种方式：1）接口传递；2）构造方法传递；3）setter方式传递。

  依赖倒转原则的注意事项和细节：1）底层模块尽量都要有抽象类或接口，或者两者都有，这样程  序稳定性更好；2）变量的声明类型尽量是抽象类或者接口，这样我们的变量引用和实际对象之间就存在一个缓冲层，利于程序扩展和优化；3）继承时遵循里氏替换原则。

* 里氏替换原则(LisKov Subsitution Principle)：

  * 引用基类的地方必须能透明地使用其子类的对象。

  * 在使用继承时，遵循里氏替换原则，子类中尽量不要重写父类的方法
  * 继承实际上让两个类耦合性增强了，在适当情况下，可以去掉继承关系，通过聚合，组合，依赖来解决问题

* 开闭原则(Open Closed Principle)：是编程中最基础、最重要的设计原则。

  * 一个软件实体如类、模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。
  * 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
  * 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

* 迪米特法则(Demeter Principle)：也叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。

  * 一个对象应该对其他对象保持最少的了解。
  * 类与类关系越密切，耦合度越大。
  * 迪米特法则还有更简单的定义：只与直接的朋友通信。
  * 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量，方法参数，方法声明的返回值(不是return)中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。
  * 迪米特法则的核心是降低类之间的耦合
  * 由于每个类减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。

* 合成复用原则(Composite Reuse Principle)：尽量使用合成/聚合的方式，而不是使用继承。

  shift+tab: 结束无序列表缩进

  

####  设计原则核心思想：

* 找出应用中可能需要变化的地方，把它们独立出来，不要和那些不需要变化的代码混在一起
* 针对接口编程，而不是针对实现编程
* 为了交互对象之间的松耦合设计而努力



<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957282.png" alt="image-20211213110917582" style="zoom:80%;" />

Aggregation：聚合 

Composite：组合



### UML类图

UML(Unified modeling language): 统一建模语言，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。 

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957283.png" alt="image-20211213135203191" style="zoom:80%;" />

使用UML来建模，常用的工具有Rational Rose，也可以使用一些插件(AmaterasUML)来建模。

UML类图：用来描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。

类之间的关系：依赖、泛化（继承）、实现、关联、聚合、组合

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957284.png" alt="image-20211213141911822" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957285.png" alt="image-20211213142257749" style="zoom:80%;" />

依赖关系：类中用到了对方，可以是：类的成员属性，方法的返回值，方法接收的参数，局部变量的形式。

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957286.png" alt="image-20211213142707702" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957287.png" alt="image-20211213142808157" style="zoom:80%;" />

泛化关系：如果A类继承了B类，我们就说A和B存在泛化关系。

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957288.png" alt="image-20211213142923629" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957289.png" alt="image-20211213143101582" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957290.png" alt="image-20211213143135430" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957291.png" alt="image-20211213143526374" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957292.png" alt="image-20211213143709717" style="zoom:80%;" />



如果Mouse，Monitor和Computer是不可分离的（伴随这Computer对象的创建Mouse和Monitor对象也会创建），则不再是聚合关系，升级为组合关系。

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957293.png" alt="image-20211213144116149" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957294.png" alt="image-20211213144212325" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957295.png" alt="image-20211213144529581" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957296.png" alt="image-20211213144434756" style="zoom:80%;" />



### 设计模式

**设计模式代表了最佳实践**，设计模式的本质：提高软件的维护性，通用性和扩展性，并降低软件的复杂度。

设计模式分为三种类型，共23种

（1）创建型模式：**单例模式**、抽象工厂模式、原型模式、建造者模式、**工厂模式** 。

（2）结构型模式：适配器模式、桥接模式、**装饰模式**、组合模式、外观模式、享元模式、**代理模式**。

（3）行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、**观察者模式**、中介者模式、备忘录模式、解释器模式(Interpreter模式)、状态模式、策略模式、职责链模式(责任链模式)。



#### 单例模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957297.png" alt="image-20211213154544954" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957298.png" alt="image-20211213154657384" style="zoom:80%;" />

饿汉式单例模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957299.png" alt="image-20211213154801587" style="zoom:80%;" />

```java
package com.pattern.singleton.hungry;

public class HungryStatic {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance2 == instance);
        System.out.println("instance.hashCode()=" + instance.hashCode());
        System.out.println("instance2.hashCode()=" + instance2.hashCode());
    }
}

// 饿汉式单例模式（静态变量）
class Singleton{
    // 1.构造器私有化，外部无法new
    private Singleton(){

    }
    // 2.本类内部创建对象实例
    private final static Singleton instance = new Singleton();
    
    // 2.另一种写法，本类内部静态代码块创建对象实例
   /* private static Singleton1 instance;
    static {
        instance = new Singleton1();
    }*/
    
    // 3.提供一个共有的静态方法，返回实例对象
    public static Singleton getInstance(){
        return instance;
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957300.png" alt="image-20211214104800346" style="zoom:80%;" />

线程不安全的懒汉式单例模式：

```java
package com.pattern.singleton.lazy;

/**
 * 懒汉式单例模式（线程不安全）
 */
public class Lazy {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance2 == instance);
        System.out.println("instance.hashCode()=" + instance.hashCode());
        System.out.println("instance2.hashCode()=" + instance2.hashCode());
    }
}

class Singleton{
    private static Singleton instance;
    private Singleton() { }

    // 提供一个静态的公有方法，当调用方法时才会创建instance
    public static Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957301.png" alt="image-20211214143920321" style="zoom:80%;" />

线程安全的懒汉式单例模式（synchronized）：

```java
package com.pattern.singleton.lazy;

/**
 * 懒汉式单例模式（线程安全，同步方法）
 */
public class LazySyn {
    public static void main(String[] args) {
        Singleton1 instance = Singleton1.getInstance();
        Singleton1 instance2 = Singleton1.getInstance();
        System.out.println(instance2 == instance);
        System.out.println("instance.hashCode()=" + instance.hashCode());
        System.out.println("instance2.hashCode()=" + instance2.hashCode());
    }
}

class Singleton1{
    private static Singleton1 instance;
    private Singleton1() { }

    // 提供一个静态的公有方法，加入同步处理代码，解决线程安全问题
    public static synchronized Singleton1 getInstance(){
        if (instance == null){
            instance = new Singleton1();
        }
        return instance;
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957302.png" alt="image-20211214144442400" style="zoom:80%;" />

线程安全的懒汉式单例模式（双重检查）：

```java
package com.pattern.singleton.lazy;

public class DoubleCheck {

    public static void main(String[] args) {
        Singleton1 instance = Singleton1.getInstance();
        Singleton1 instance2 = Singleton1.getInstance();
        System.out.println(instance2 == instance);
        System.out.println("instance.hashCode()=" + instance.hashCode());
        System.out.println("instance2.hashCode()=" + instance2.hashCode());
    }

}

class Singleton2 {
    private static volatile Singleton2 instance;

    private Singleton2(){};

    // 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题,
    // 解决了懒加载问题，同时保证了效率，推荐使用。
    public static synchronized Singleton2 getInstance(){
        if (instance == null){
            synchronized (Singleton2.class){
                if (instance == null) {
                    instance = new Singleton2();
                }
            }
        }
        return instance;
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957303.png" alt="image-20211214160825260" style="zoom:80%;" />

静态内部类实现单例模式：

```java
package com.pattern.singleton.lazy;

/**
 * 使用静态内部类实现懒汉式单例模式，推荐使用
 */
public class StaticClass {
    public static void main(String[] args) {
        Singleton1 instance = Singleton1.getInstance();
        Singleton1 instance2 = Singleton1.getInstance();
        System.out.println(instance2 == instance);
        System.out.println("instance.hashCode()=" + instance.hashCode());
        System.out.println("instance2.hashCode()=" + instance2.hashCode());
    }
}

// 静态内部类实现单例模式
class Singleton3 {
    private static Singleton3 instance;
    private Singleton3(){}

    private static class Singleton3Instance{
        private static final Singleton3 INSTANCE = new Singleton3();
    }

    public static Singleton3 getInstance(){
        return Singleton3Instance.INSTANCE;
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957304.png" alt="image-20211214162448670" style="zoom:80%;" />

使用枚举实现单例模式：

```java
package com.pattern.singleton.lazy;

public class Enum {
    public static void main(String[] args) {
        Singleton4 instance = Singleton4.INSTANCE;
        Singleton4 instance2 = Singleton4.INSTANCE;
        System.out.println(instance == instance2);

        System.out.println(instance.hashCode());
        System.out.println(instance2.hashCode());
        instance.sayOk();
    }

}

// 使用枚举，可以实现单例，推荐
enum Singleton4 {
    INSTANCE; // 属性
    public void sayOk(){
        System.out.println("OK~");
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957305.png" alt="image-20211214163216940" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112141957306.png" alt="image-20211214163628500" style="zoom:80%;" />



#### 简单工厂模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151814629.png" alt="image-20211215181400530" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112142108111.png" alt="image-20211214210849017" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151003393.png" alt="image-20211215100331268" style="zoom:80%;" />

```java
package com.pattern.factory.simplefactory.pizza;

/**
 * 披萨类，披萨的制作过程
 */
public abstract class Pizza {
    protected String name;
    //准备制作披萨的原材料
    public abstract void prepare();

    public void bake(){
        System.out.println(name + " baking;");
    }
    public void cut(){
        System.out.println(name + " cutting;");
    }
    public void box(){
        System.out.println(name + " boxing;");
    }

    public void setName(String name){
        this.name = name;
    }
}
```

```java
package com.pattern.factory.simplefactory.pizza;

public class CheesePizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("为奶酪披萨准备原材料。。。");
    }
}
```

```java
package com.pattern.factory.simplefactory.order;

import com.pattern.factory.simplefactory.pizza.CheesePizza;
import com.pattern.factory.simplefactory.pizza.GreekPizza;
import com.pattern.factory.simplefactory.pizza.PepperPizza;
import com.pattern.factory.simplefactory.pizza.Pizza;

// 简单工厂类
public class SimpleFactory {

    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        System.out.println("使用简单工厂模式");
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        } else if (orderType.equals("cheese")) {
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        } else if (orderType.equals("pepper")) {
            pizza = new PepperPizza();
            pizza.setName("胡椒披萨");
        }
        return pizza;
    }

    // 简单工厂模式 也叫 静态工厂模式
    public static Pizza createPizza2(String orderType) {
        Pizza pizza = null;
        System.out.println("使用简单工厂模式");
        if (orderType.equals("greek")) {
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        } else if (orderType.equals("cheese")) {
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        } else if (orderType.equals("pepper")) {
            pizza = new PepperPizza();
            pizza.setName("胡椒披萨");
        }
        return pizza;
    }

}
```

```java
package com.pattern.factory.simplefactory.order;

import com.pattern.factory.simplefactory.pizza.CheesePizza;
import com.pattern.factory.simplefactory.pizza.GreekPizza;
import com.pattern.factory.simplefactory.pizza.PepperPizza;
import com.pattern.factory.simplefactory.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
// 订购披萨
public class OrderPizza {

    // 构造器
    /*public OrderPizza() {
        Pizza pizza = null;
        String orderType; // 订购的披萨类型
        do{
            orderType = getType();
            if (orderType.equals("greek")) {
                pizza = new GreekPizza();
                pizza.setName("希腊披萨");
            } else if (orderType.equals("cheese")) {
                pizza = new CheesePizza();
                pizza.setName("奶酪披萨");
            } else if (orderType.equals("pepper")) {
                pizza = new PepperPizza();
                pizza.setName("胡椒披萨");
            }else {
                break;
            }
            // 输出pizza制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while (true);
    }*/  // 现实中会有多个OrderPizza，如果增加一个PepperPizza，每个OrderPizza都需要更改。

    // 使用聚合方式定义一个简单工厂对象
    SimpleFactory simpleFactory;
    Pizza pizza = null;

    // 构造器
    public OrderPizza(SimpleFactory simpleFactory) {
        setSimpleFactory(simpleFactory);
    }

    public void setSimpleFactory(SimpleFactory simpleFactory) {
        String orderType = ""; // 用户输入
        this.simpleFactory = simpleFactory; // 设置简单工厂对象

        do {
            orderType = getType(); // 输入订购的披萨种类
            pizza = this.simpleFactory.createPizza(orderType); // 获得对应种类的pizza对象
            // 输出pizza
            if (pizza != null) {
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            } else {
                System.out.println("===== 订购披萨失败，无此类披萨 =====");
                break;
            }
        } while (true);
    }

    // 获取客户想要订购的披萨类型
    private String getType() {
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input the pizza's type: ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}
```

```java
package com.pattern.factory.simplefactory.order;

import com.pattern.factory.simplefactory.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

// 简单工厂模式 也叫 静态工厂模式
public class OrderPizza2 {

    Pizza pizza = null;
    String orderType = "";

    // 构造器
    public OrderPizza2() {
        do {
            orderType = getType(); // 输入订购的披萨种类
            pizza = SimpleFactory.createPizza2(orderType); // 获得对应种类的pizza对象
            // 输出pizza
            if (pizza != null) {
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            } else {
                System.out.println("===== 订购披萨失败，无此类披萨 =====");
                break;
            }
        } while (true);
    }

    // 获取客户想要订购的披萨类型
    private String getType() {
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input the pizza's type: ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}
```

```java
package com.pattern.factory.simplefactory.order;

/**
 * 相当于一个客户端，发出订购披萨的请求
 */
public class PizzaStore {
    public static void main(String[] args) {

        // new OrderPizza();

        // 使用简单工厂模式
        new OrderPizza(new SimpleFactory());
        System.out.println("~~~ 退出程序 ~~~");

        // new OrderPizza2(); 使用静态(简单)工厂模式
    }
}
```



#### 工厂方法模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151110659.png" alt="image-20211215111053553" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151228273.png" alt="image-20211215122858184" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151233233.png" alt="image-20211215123311159" style="zoom:80%;" />

```java
package com.pattern.factory.factorymethod.pizza;

/**
 * 披萨类，披萨的制作过程
 */
public abstract class Pizza {
    protected String name;
    public Pizza(){}
    //准备制作披萨的原材料
    public abstract void prepare();

    public void bake(){
        System.out.println(name + " baking;");
    }
    public void cut(){
        System.out.println(name + " cutting;");
    }
    public void box(){
        System.out.println(name + " boxing;");
    }

    public void setName(String name){
        this.name = name;
    }
}
```

```java
package com.pattern.factory.factorymethod.pizza;

public class BJCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京奶酪披萨");
        System.out.println("北京的奶酪披萨 准备原材料...");
    }
}
```

```java
package com.pattern.factory.factorymethod.pizza;

public class BJPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京胡椒披萨");
        System.out.println("北京的胡椒披萨 准备原材料...");
    }
}
```

```java
package com.pattern.factory.factorymethod.order;


import com.pattern.factory.factorymethod.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

// 订购披萨
public abstract class OrderPizza {

    // 定义一个抽象方法，createPizza，让各个工厂子类自己实现
    abstract Pizza createPizza(String orderType);

    // 构造器
    public OrderPizza() {
        Pizza pizza = null;
        String orderType; // 订购的披萨类型
        do {
            orderType = getType();
            pizza = createPizza(orderType); // 抽象方法，由工厂子类实现
            // 输出pizza制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        } while (true);
    }

    // 获取客户想要订购的披萨类型
    protected String getType() {
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("请输入订购披萨的 口味 和 种类：");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

```java
package com.pattern.factory.factorymethod.order;

import com.pattern.factory.factorymethod.pizza.BJCheesePizza;
import com.pattern.factory.factorymethod.pizza.BJPepperPizza;
import com.pattern.factory.factorymethod.pizza.Pizza;
import com.sun.org.apache.xpath.internal.operations.Or;

public class BJOrderPizza extends OrderPizza{
    @Override
    Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new BJCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new BJPepperPizza();
        }
        return pizza;
    }
}
```

```java
package com.pattern.factory.factorymethod.order;

import com.pattern.factory.factorymethod.pizza.*;

public class LDOrderPizza extends OrderPizza{
    @Override
    Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new LDCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}
```

```java
package com.pattern.factory.factorymethod.order;

public class PizzaStore {
    public static void main(String[] args) {
        // 创建北京口味的披萨
        new BJOrderPizza();
        // 创建伦敦口味的披萨
        new LDOrderPizza();
    }
}
```



#### 抽象工厂模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151557351.png" alt="image-20211215155725243" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151631735.png" alt="image-20211215163154665" style="zoom:80%;" />

```java
package com.pattern.factory.absfactory.pizza;

/**
 * 披萨类，披萨的制作过程
 */
public abstract class Pizza {
    protected String name;
    public Pizza(){}
    //准备制作披萨的原材料
    public abstract void prepare();

    public void bake(){
        System.out.println(name + " baking;");
    }
    public void cut(){
        System.out.println(name + " cutting;");
    }
    public void box(){
        System.out.println(name + " boxing;");
    }

    public void setName(String name){
        this.name = name;
    }
}
```

```java
package com.pattern.factory.absfactory.pizza;

public class BJCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("北京奶酪披萨");
        System.out.println("北京的奶酪披萨 准备原材料...");
    }
}
```



```java
package com.pattern.factory.absfactory.order;
import com.pattern.factory.absfactory.pizza.Pizza;
/**
 * 一个抽象工厂模式的抽象层（接口）
 */
public interface AbsFactory {
    // 让下面的工厂子类来具体实现
    public Pizza createPizza(String orderType);
}
```

```java
package com.pattern.factory.absfactory.order;

import com.pattern.factory.absfactory.pizza.BJCheesePizza;
import com.pattern.factory.absfactory.pizza.LDPepperPizza;
import com.pattern.factory.absfactory.pizza.Pizza;
// 工厂子类
public class BJFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        System.out.println("使用抽象工厂模式");
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new BJCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}
```

```java
package com.pattern.factory.absfactory.order;

import com.pattern.factory.absfactory.pizza.BJCheesePizza;
import com.pattern.factory.absfactory.pizza.LDCheesePizza;
import com.pattern.factory.absfactory.pizza.LDPepperPizza;
import com.pattern.factory.absfactory.pizza.Pizza;
// 工厂子类
public class LDFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        System.out.println("使用抽象工厂模式");
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new LDCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new LDPepperPizza();
        }
        return pizza;
    }
}
```

```java
package com.pattern.factory.absfactory.order;

import com.pattern.factory.absfactory.pizza.Pizza;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OrderPizza {

    AbsFactory absFactory = null;

    public OrderPizza(AbsFactory absFactory){
        setAbsFactory(absFactory);
    }

    private void setAbsFactory(AbsFactory absFactory) {
        Pizza pizza = null;
        String orderType = ""; // 用户输入
        this.absFactory = absFactory;

        do{
            orderType = getType();
            pizza = absFactory.createPizza(orderType);
            if (pizza != null){
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            }else {
                System.out.println("订购失败");
                break;
            }
        } while (true);
    }



    // 获取客户想要订购的披萨类型
    protected String getType() {
        try {
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("请输入订购披萨口味> ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

```java
package com.pattern.factory.absfactory.order;

public class PizzaStore {
    public static void main(String[] args) {
        //new OrderPizza(new BJFactory());
        new OrderPizza(new LDFactory());
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151808205.png" alt="image-20211215180840088" style="zoom:80%;" />

### 

#### 原型模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151849290.png" alt="image-20211215184921210" style="zoom:80%;" />

```java
public class Sheep {
    private String name;
    private int age;
    private String color;
}
```

传统方法解决克隆羊问题：

```java
package com.pattern.prototype;

public class Client {
    public static void main(String[] args) {
        // 传统的方法
        Sheep sheep = new Sheep("tom", 1, "白色");

        Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());

        System.out.println(sheep);
        System.out.println(sheep2);
        System.out.println(sheep3);
        System.out.println(sheep4);
        System.out.println(sheep5);
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151851039.png" alt="image-20211215185103945" style="zoom:80%;" />



<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151826072.png" alt="image-20211215182648972" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151844039.png" alt="image-20211215184450947" style="zoom:80%;" />

原型模式解决克隆羊问题：

```java
public class Sheep implements Cloneable{
    private String name;
    private int age;
    private String color;
    private String type = "蒙古羊";
    
        // 克隆该实例，使用默认的clone方法完成
    @Override
    protected Object clone() {
        Sheep sheep = null;
        try {
            sheep = (Sheep) super.clone();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return sheep;
    }
}
```

```java
package com.pattern.prototype.improve;

public class Client {
    public static void main(String[] args) {
        System.out.println("原型模式完成对象的创建");
        Sheep sheep = new Sheep("tom", 1, "白色");
        Sheep sheep2 = (Sheep) sheep.clone(); // 用原型模式克隆得到对象实例
        Sheep sheep3 = (Sheep) sheep.clone();
        Sheep sheep4 = (Sheep) sheep.clone();
        Sheep sheep5 = (Sheep) sheep.clone();

        System.out.println("sheep=" + sheep);
        System.out.println("sheep2=" + sheep2);
        System.out.println("sheep3=" + sheep3);
        System.out.println("sheep4=" + sheep4);
        System.out.println("sheep5=" + sheep5);
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112151936517.png" alt="image-20211215193654401" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112152049296.png" alt="image-20211215204929204" style="zoom:80%;" />

对于数据类型是引用类型的成员变量，浅拷贝只是将该成员变量的地址复制给新对象，两个对象指向同一地址：

```java
package com.pattern.prototype.improve;

public class Sheep implements Cloneable{
    private String name;
    private int age;
    private String color;
    private String type = "蒙古羊";
    public Dog friend;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                ", type='" + type + '\'' +
                '}';
    }

    // 克隆该实例，使用默认的clone方法完成
    @Override
    protected Object clone() {
        Sheep sheep = null;
        try {
            sheep = (Sheep) super.clone();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return sheep;
    }
}

class Dog {
    private String name;
    private int age;
    private String color;

    public Dog(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }
}
```

```java
package com.pattern.prototype.improve;

public class Client {
    public static void main(String[] args) {
        System.out.println("原型模式完成对象的创建");
        Sheep sheep = new Sheep("tom", 1, "白色");
        sheep.friend = new Dog("Jerry", 1, "黑色");
        Sheep sheep2 = (Sheep) sheep.clone(); // 用原型模式克隆得到对象实例(属性相同的不同对象)
        Sheep sheep3 = (Sheep) sheep.clone();
        Sheep sheep4 = (Sheep) sheep.clone();
        Sheep sheep5 = (Sheep) sheep.clone();

        System.out.println("sheep=" + sheep + "sheep.friend=" + sheep.friend.hashCode());
        System.out.println("sheep2=" + sheep2 + "sheep2.friend=" + sheep2.friend.hashCode());
        System.out.println("sheep3=" + sheep3 + "sheep3.friend=" + sheep3.friend.hashCode());
        System.out.println("sheep4=" + sheep4 + "sheep4.friend=" + sheep4.friend.hashCode());
        System.out.println("sheep5=" + sheep5 + "sheep5.friend=" + sheep5.friend.hashCode());
    }
}
```

利用深拷贝解决引用类型克隆问题：

```java
package com.pattern.prototype.deepclone;

import java.io.Serializable;

public class DeepCloneableTarget implements Serializable,Cloneable {

    private static final long serialVersionUID = 1L;
    private String cloneName;
    private String cloneClass;

    public DeepCloneableTarget(String cloneName, String cloneClass) {
        this.cloneName = cloneName;
        this.cloneClass = cloneClass;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```java
package com.pattern.prototype.deepclone;

import java.io.*;

public class DeepCloneProtoType implements Serializable,Cloneable {
    public String name; // String 属性
    public DeepCloneableTarget deepCloneableTarget; // 引用类型

    public DeepCloneProtoType() {
    }

    // 深拷贝 - 方式1：使用clone方法
    @Override
    protected Object clone() throws CloneNotSupportedException {

        Object deep = null;
        // 完成对基本类型(属性)和String的克隆
        deep = super.clone();
        // 对应用类型的属性，进行单独的处理
        DeepCloneProtoType deepCloneProtoType = (DeepCloneProtoType) deep;
        deepCloneProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();
        return deepCloneProtoType;

    }

    // 深拷贝 - 方式2：通过对象的序列化实现（推荐）
    public Object deepClone() {
        ByteArrayOutputStream bos = null;
        ByteArrayInputStream bis = null;
        ObjectOutputStream oos = null;
        ObjectInputStream ois = null;

        try {
            // 序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this); // 将当前这个对象以对象流的方式输出
            // 反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepCloneProtoType cloneProtoType = (DeepCloneProtoType) ois.readObject();
            return cloneProtoType;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }finally {
            // 关闭流
            try {
                bis.close();
                ois.close();
                oos.close();
                bos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

}
```

```java
package com.pattern.prototype.deepclone;

public class Client {

    public static void main(String[] args) throws CloneNotSupportedException {
        DeepCloneProtoType p = new DeepCloneProtoType();
        p.name = "张三";
        p.deepCloneableTarget = new DeepCloneableTarget("李四", "li4");

        // 方式1完成深拷贝
        /*DeepCloneProtoType p2 = (DeepCloneProtoType) p.clone();
        System.out.println("p.name=" + p.name + " p.DeepCloneableTarget.hashCode=" + p.deepCloneableTarget.hashCode());
        System.out.println("p2.name=" + p2.name + " p2.DeepCloneableTarget.hashCode=" + p2.deepCloneableTarget.hashCode());*/

        // 方式2：完成深拷贝
        DeepCloneProtoType p2 = (DeepCloneProtoType) p.clone();
        System.out.println("p.name=" + p.name + " p.DeepCloneableTarget.hashCode=" + p.deepCloneableTarget.hashCode());
        System.out.println("p2.name=" + p2.name + " p2.DeepCloneableTarget.hashCode=" + p2.deepCloneableTarget.hashCode());

    }

}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112160927261.png" alt="image-20211216092709121" style="zoom:80%;" />



#### 建造者模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112160938836.png" alt="image-20211216093814743" style="zoom:80%;" />

传统方式解决盖房问题：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161016314.png" alt="image-20211216101644229" style="zoom:80%;" />

```java
package com.pattern.builder.general;

public abstract class AbstractHouse {

    // 打地基
    public abstract void buildBasic();
    // 砌墙
    public abstract void buildWalls();
    // 封顶
    public abstract void roofed();

    public void build() {
        buildBasic();
        buildWalls();
        roofed();
    }

}
```

```java
package com.pattern.builder.general;

public class CommonHouse extends AbstractHouse{

    @Override
    public void buildBasic() {
        System.out.println("普通房子打地基");
    }

    @Override
    public void buildWalls() {
        System.out.println("普通房子打砌墙");
    }

    @Override
    public void roofed() {
        System.out.println("普通房子打封顶");
    }
}
```

```java
package com.pattern.builder.general;

public class Client {
    public static void main(String[] args) {
        CommonHouse commonHouse = new CommonHouse();
        commonHouse.build();
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161019373.png" alt="image-20211216101949276" style="zoom:80%;" />

将产品和产品的建造过程解耦。

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161022981.png" alt="image-20211216102213872" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161023827.png" alt="image-20211216102312733" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161026705.png" alt="image-20211216102602606" style="zoom:80%;" />

可以将抽象类写成接口

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161027785.png" alt="image-20211216102744693" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161028370.png" alt="image-20211216102855277" style="zoom:80%;" />

聚合和组合的箭头指向：谁声明就指向谁。

<img src="http://images.cnitblog.com/blog/349217/201309/15113822-a45fa292737d4c7884acbf250e18e3df.png" alt="img" style="zoom: 80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161052051.png" alt="image-20211216105227952" style="zoom:80%;" />

```java
package com.pattern.builder.improve;

// 产品->product
public class House {
    private String basic;
    private String wall;
    private String roof;

    public String getBasic() {
        return basic;
    }

    public void setBasic(String basic) {
        this.basic = basic;
    }

    public String getWall() {
        return wall;
    }

    public void setWall(String wall) {
        this.wall = wall;
    }

    public String getRoof() {
        return roof;
    }

    public void setRoof(String roof) {
        this.roof = roof;
    }
}
```

```java
package com.pattern.builder.improve;

// 抽象的建造者，描述建造房子该有的流程
public abstract class HouseBuilder {

    protected House house = new House();

    // 描述建造的流程，抽象方法
    public abstract void buildBasic();
    public abstract void buildWall();
    public abstract void roofed();

    // 建造好房子之后，将产品（房子）返回
    public House buildHouse() {
        return house;
    }

}
```

```java
package com.pattern.builder.improve;

// 指挥者，指定制作流程，返回产品
public class HouseDirector {

    HouseBuilder houseBuilder = null;
    // 构造器传入houseBuilder
    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }
    // 也可以用set方法注入houseBuilder
    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    // 如何处理建造房子的流程，交给指挥者处理
    public House constructBuild() {
        houseBuilder.buildBasic();
        houseBuilder.buildWall();
        houseBuilder.roofed();
        return houseBuilder.buildHouse();
    }
}
```

```java
package com.pattern.builder.improve;

public class CommonHouse extends HouseBuilder{

    @Override
    public void buildBasic() {
        house.setBasic("5米");
        System.out.println("普通房子打地基 " + house.getBasic());
    }

    @Override
    public void buildWall() {
        house.setWall("10厘米");
        System.out.println("普通房子砌墙 " + house.getWall());
    }

    @Override
    public void roofed() {
        house.setRoof("平顶");
        System.out.println("普通房子 " + house.getRoof());
    }
}
```

```java
package com.pattern.builder.improve;

// 具体建造类里面，可以使用产品对象(House)
public class HighHouse extends HouseBuilder{
    @Override
    public void buildBasic() {
        house.setBasic("20米");
        System.out.println("高楼打地基 " + house.getBasic());
    }

    @Override
    public void buildWall() {
        house.setWall("20厘米");
        System.out.println("高楼砌墙 " + house.getWall());
    }

    @Override
    public void roofed() {
        house.setRoof("坡顶");
        System.out.println("高楼透明 " + house.getRoof());
    }
}
```

```java
package com.pattern.builder.improve;

public class Client {
    public static void main(String[] args) {

        // 盖普通房
        CommonHouse commonHouse = new CommonHouse();
        // 准备创建房子的指挥者
        HouseDirector houseDirector = new HouseDirector(commonHouse);
        // 完成盖房子，返回产品（房子）
        House house = houseDirector.constructBuild();
        System.out.println("-----------------------");
        // 盖高楼
        HighHouse highHouse = new HighHouse();
        // 重置建造者
        houseDirector.setHouseBuilder(highHouse);
        // 完成盖房子，返回产品（高楼）
        houseDirector.constructBuild();
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161452511.png" alt="image-20211216145233380" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161453158.png" alt="image-20211216145345033" style="zoom:80%;" />

#### 适配器模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161500238.png" alt="image-20211216150043129" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161503888.png" alt="image-20211216150335777" style="zoom:80%;" />

类适配器模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161505923.png" alt="image-20211216150533808" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161518044.png" alt="image-20211216151840939" style="zoom:80%;" />

voltage: 电压

```java
package com.pattern.adapter.classadapter;

// 被适配的类
public class Voltage220V {
    // 输出220V的电压
    public int output220V(){
        int src = 220;
        System.out.println("源电压 = " + 220 + "伏");
        return src;
    }
}
```

```java
package com.pattern.adapter.classadapter;

// 被适配的类
public class Voltage220V {
    // 输出220V的电压
    public int output220V(){
        int src = 220;
        System.out.println("源电压 = " + 220 + "伏");
        return src;
    }
}
```

```java
package com.pattern.adapter.classadapter;

// 适配器类
public class VoltageAdapter extends Voltage220V implements IVoltage5V{

    @Override
    public int output5V() {
        // 获取到220V电压，并转换成5V的电压
        int srcVol = output220V();
        int dstVol = srcVol / 44;
        return dstVol;
    }
}
```

```java
package com.pattern.adapter.classadapter;

public class Phone {
    // 充电
    public void charging(IVoltage5V iVoltage5V) {
        if (iVoltage5V.output5V() == 5) {
            System.out.println("电压为5V，可以充电");
        } else {
            System.out.println("电压不等于5V，不能充电");
        }
    }
}
```

```java
package com.pattern.adapter.classadapter;

public class Client {
    public static void main(String[] args) {
        // 类适配器模式
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter());
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161533218.png" alt="image-20211216153304082" style="zoom:80%;" />

对象适配器：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161536725.png" alt="image-20211216153636614" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161537535.png" alt="image-20211216153733425" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161542500.png" alt="image-20211216154229392" style="zoom:80%;" />

只需修改：

```java
package com.pattern.adapter.objectadapter;

// 适配器类
public class VoltageAdapter implements IVoltage5V {
    // 聚合
    private Voltage220V voltage220V;

    public VoltageAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    @Override
    public int output5V() {
        int dstVol = 0;
        if (null != voltage220V) {
            int srcVol = voltage220V.output220V();
            dstVol = srcVol / 44;
            System.out.println("220V->5V 适配完成");
        }
        return dstVol;
    }
}
```

```java
package com.pattern.adapter.objectadapter;

public class Client {
    public static void main(String[] args) {
        System.out.println("=== 对象适配器模式 ===");
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter(new Voltage220V()));
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161550674.png" alt="image-20211216155056520" style="zoom:80%;" />

接口适配器模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161606416.png" alt="image-20211216160630290" style="zoom:80%;" />

抽象类能以匿名内部类的方式创建实例

```java
package com.pattern.adapter.interfaceadapter;

public interface Interface1 {
    public void m1();
    public void m2();
    public void m3();
    public void m4();
}
```

```java
package com.pattern.adapter.interfaceadapter;

public abstract class InterAdapter implements Interface1{
    // 将Interface1的方法进行默认实现
    public void m1(){}
    public void m2(){}
    public void m3(){}
    public void m4(){}
}
```

```java
package com.pattern.adapter.interfaceadapter;

public class Client {
    public static void main(String[] args) {
        InterAdapter interAdapter = new InterAdapter() {
            // 只需要去覆盖我们需要使用的接口方法
            @Override
            public void m1() {
                System.out.println("使用了Interface1接口中的m1()方法");
            }
        };
        interAdapter.m1();
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161629152.png" alt="image-20211216162950026" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161637287.png" alt="image-20211216163714148" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112161636780.png" alt="image-20211216163651659" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112162043085.png" alt="image-20211216204300944" style="zoom:80%;" />



#### 桥接模式：





<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171046209.png" alt="image-20211217104624126" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171045079.png" alt="image-20211217104543990" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171047074.png" alt="image-20211217104713989" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112162049143.png" alt="image-20211216204953039" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112162056488.png" alt="image-20211216205648374" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112162101459.png" alt="image-20211216210135374" style="zoom:80%;" />



<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112162100706.png" alt="image-20211216210059629" style="zoom:80%;" />

```java
package com.pattern.bridge;

// 接口
public interface Brand {
    void open();
    void close();
    void call();
}
```

```java
package com.pattern.bridge;

public class Vivo implements Brand{
    @Override
    public void open() {
        System.out.println("vivo手机开机");
    }

    @Override
    public void close() {
        System.out.println("vivo手机关机");
    }

    @Override
    public void call() {
        System.out.println("vivo手机打电话");
    }
}
```

```java
package com.pattern.bridge;

public class XiaoMi implements Brand{
    @Override
    public void open() {
        System.out.println("小米手机开机");
    }

    @Override
    public void close() {
        System.out.println("小米手机关机");
    }

    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}
```

```java
package com.pattern.bridge;

// 充当桥的角色
public abstract class Phone {
    // 组合品牌
    private Brand brand;

    public Phone(Brand brand) {
        this.brand = brand;
    }
    protected void open(){
        brand.open();
    }
    protected void close(){
        brand.close();
    }
    protected void call(){
        brand.call();
    }

}
```

```java
package com.pattern.bridge;

public class FoldedPhone extends Phone{

    public FoldedPhone(Brand brand) {
        super(brand);
    }

    public void open(){
        super.open();
        System.out.println("折叠式手机");
    }
    public void close(){
        super.close();
        System.out.println("折叠式手机");
    }

    public void call(){
        super.call();
        System.out.println("折叠式手机");
    }
}
```

```java
package com.pattern.bridge;

public class UpRightPhone extends Phone{

    public UpRightPhone(Brand brand) {
        super(brand);
    }

    public void open(){
        super.open();
        System.out.println("直立式手机");
    }
    public void close(){
        super.close();
        System.out.println("直立式手机");
    }

    public void call(){
        super.call();
        System.out.println("直立式手机");
    }
}
```

```java
package com.pattern.bridge;

public class Client {
    public static void main(String[] args) {
        // 获取折叠式手机（样式+品牌）
        Phone p1 = new FoldedPhone(new XiaoMi());
        p1.open();
        p1.call();
        p1.close();
        System.out.println("=====================");
        Phone p2 = new FoldedPhone(new Vivo());
        p2.open();
        p2.call();
        p2.close();
        System.out.println("=====================");
        Phone p3 = new UpRightPhone(new XiaoMi());
        p3.open();
        p3.call();
        p3.close();
        System.out.println("====================");
        Phone p4 = new UpRightPhone(new Vivo());
        p4.open();
        p4.call();
        p4.close();
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112162126349.png" alt="image-20211216212619229" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112170950819.png" alt="image-20211217095059644" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171043807.png" alt="image-20211217104314694" style="zoom:80%;" />

#### 装饰者设计模式:

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171050651.png" alt="image-20211217105005558" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171051503.png" alt="image-20211217105147422" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171054435.png" alt="image-20211217105449341" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171057830.png" alt="image-20211217105723735" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171100709.png" alt="image-20211217110043622" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171101629.png" alt="image-20211217110148549" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171106280.png" alt="image-20211217110603166" style="zoom:80%;" />

<img src="../AppData/Roaming/Typora/typora-user-images/image-20211217121448161.png" alt="image-20211217121448161" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171217541.png" alt="image-20211217121710457" style="zoom:80%;" />

```java
package com.pattern.decorator;

public abstract class Drink {
    public String describe; // 描述
    private float price = 0.0f;

    public String getDescribe() {
        return describe;
    }

    public void setDescribe(String describe) {
        this.describe = describe;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    // 计算费用的抽象方法，由子类来实现
    public abstract float cost();

}
```

```java
package com.pattern.decorator;

public class Coffee extends Drink{
    @Override
    public float cost() {
        return super.getPrice();
    }
}
```

```java
package com.pattern.decorator;

// 单品咖啡
public class EspressoCoffee extends Coffee{
    public EspressoCoffee() {
        this.setDescribe("意大利咖啡");
        this.setPrice(6.0f);
    }
}
```

```java
package com.pattern.decorator;

// 单品咖啡
public class LongBlackCoffee extends Coffee{
    public LongBlackCoffee() {
        this.setDescribe("里氏咖啡");
        this.setPrice(5.0f);
    }
}
```

```java
package com.pattern.decorator;

// 单品咖啡
public class ShortBlackCoffee extends Coffee{
    public ShortBlackCoffee() {
        this.setDescribe("ShortBlack咖啡");
        this.setPrice(5.5f);
    }
}
```

```java
package com.pattern.decorator;

// 装饰器
public class Decorator extends Drink{
    private Drink obj;
    public Decorator(Drink obj) { // 组合被装饰者(单品咖啡)
        this.obj = obj;
    }
    @Override
    public float cost() {
        // 调料价格 + 单品价格
        return super.getPrice() + obj.cost();
    }

    @Override
    public String getDescribe() {
        // 返回调料描述 + 调料价格 and 被装饰的单品咖啡描述
        return super.getDescribe() + "￥" + super.getPrice() + " 和 " + obj.getDescribe();
    }
}
```

```java
package com.pattern.decorator;

// 调料，具体的Decorator
public class Milk extends Decorator{

    public Milk(Drink obj) {
        super(obj);
        this.setDescribe("牛奶");
        this.setPrice(3.5f);
    }
}
```

```java
package com.pattern.decorator;

// 调料，具体的Decorator
public class Soy extends Decorator{
    public Soy(Drink obj) {
        super(obj);
        this.setDescribe("豆浆");
        this.setPrice(2.0f);
    }
}
```

```java
package com.pattern.decorator;

// 调料，具体的Decorator
public class Chocolate extends Decorator{

    public Chocolate(Drink obj) {
        super(obj);
        this.setDescribe("巧克力");
        this.setPrice(3.0f);
    }
}
```

```java
package com.pattern.decorator;

public class CoffeeBar {
    public static void main(String[] args) {
        // 装饰者模式下订单：两份巧克力 + 一份牛奶的LongBlack
        // 1. 点一份LongBlack
        Drink order = new LongBlackCoffee();
        System.out.println("描述：" + order.getDescribe());
        System.out.println(order.getDescribe() + " 总费用1 ==》 " + order.cost());

        // 2. 在order中加入一根牛奶
        order = new Milk(order);
        System.out.println("描述：" + order.getDescribe());
        System.out.println(order.getDescribe() + " 总费用2 ==》 " + order.cost());

        // 3. 在order中加入一份巧克力
        order = new Chocolate(order);
        System.out.println("描述：" + order.getDescribe());
        System.out.println(order.getDescribe() + " 总费用3 ==》 " + order.cost());

        // 3. 在order中再加入一份巧克力
        order = new Chocolate(order);
        System.out.println("描述：" + order.getDescribe());
        System.out.println(order.getDescribe() + " 总费用4 ==》 " + order.cost());
    }

}
```





<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171507439.png" alt="image-20211217150733320" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171512767.png" alt="image-20211217151241661" style="zoom:80%;" />



#### 组合模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171518230.png" alt="image-20211217151846135" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171519176.png" alt="image-20211217151935094" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171520806.png" alt="image-20211217152039709" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171520017.png" alt="image-20211217152053925" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171528831.png" alt="image-20211217152805726" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171528009.png" alt="image-20211217152843917" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112171633835.png" alt="image-20211217163341745" style="zoom:80%;" />

Department就是叶子节点，College和University就是Composite

```java
package com.pattern.composite;

public abstract class OrganizationComponent {

    private String name; // 名字
    private String des;  // 说明

    protected void add(OrganizationComponent organizationComponent){
        // 提供默认实现
        throw new UnsupportedOperationException();
    }
    protected void remove(OrganizationComponent organizationComponent){
        // 提供默认实现
        throw new UnsupportedOperationException();
    }
    // 抽象类可以有构造器，由子类构造器实现
    public OrganizationComponent(String name, String des) {
        this.name = name;
        this.des = des;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    // print方法，写出抽象方法，子类都需要实现
    protected abstract void print();
}
```

```java
package com.pattern.composite;

import java.util.ArrayList;
import java.util.List;

public class University extends OrganizationComponent{

    List<OrganizationComponent> organizationComponents = new ArrayList<>();

    public University(String name, String des) {
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        System.out.println("添加学院：" + organizationComponent.getName());
        organizationComponents.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        System.out.println("移除学院：" + organizationComponent.getName());
        organizationComponents.add(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    // print方法，输出University包含的学院
    @Override
    protected void print() {
        System.out.println("---------" + getName() + "---------");
        // 遍历organizationComponents
        for (OrganizationComponent o :
                organizationComponents) {
            o.print();
        }
    }
}
```

```java
package com.pattern.composite;

import java.util.ArrayList;
import java.util.List;

public class College extends OrganizationComponent{
    // List 中存放的是 Department
    List<OrganizationComponent> organizationComponents = new ArrayList<>();

    public College(String name, String des) {
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        System.out.println("添加系别：" + organizationComponent.getName());
        organizationComponents.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        System.out.println("移除系别：" + organizationComponent.getName());
        organizationComponents.add(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    // print方法，输出College包含的系
    @Override
    protected void print() {
        System.out.println("---------" + getName() + "---------");
        // 遍历organizationComponents
        for (OrganizationComponent o :
                organizationComponents) {
            o.print();
        }
    }
}
```

```java
package com.pattern.composite;

// 叶子节点
public class Department extends OrganizationComponent{

    // 没有集合
    public Department(String name, String des) {
        super(name, des);
    }

    @Override
    protected void print() {
        System.out.println("---" + getName());
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }
}
```

```java
package com.pattern.composite;

public class Client {
    public static void main(String[] args) {
        // 从大到小创建对象
        // 创建学校
        OrganizationComponent university = new University("哈工大", "985高校");
        // 创建学院
        OrganizationComponent college1 = new College("信息工程学院", "计算机类学院");
        OrganizationComponent college2 = new College("美术学院", "艺术类学院");
        university.add(college1);
        university.add(college2);
        // 创建学院下面的系
        college1.add(new Department("计算机系", "厉害"));
        college1.add(new Department("电子信息系", "一般"));
        college1.add(new Department("计算机理论系", "还行"));
        college2.add(new Department("土测系", "一流"));
        college2.add(new Department("艺术系", "厉害"));
        // university.print();
        college1.print();
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172056093.png" alt="image-20211217205604000" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172055963.png" alt="image-20211217205524840" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172059546.png" alt="image-20211217205932462" style="zoom:80%;" />

#### 外观模式：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172103319.png" alt="image-20211217210344241" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172105700.png" alt="image-20211217210535616" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172107319.png" alt="image-20211217210706224" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172108494.png" alt="image-20211217210849424" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112172113947.png" alt="image-20211217211319856" style="zoom:80%;" />













#### 代理模式：

静态代理：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112181521979.png" alt="image-20211218152158836" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112181523420.png" alt="image-20211218152325362" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112181526512.png" alt="image-20211218152622442" style="zoom:80%;" />

```java
package com.pattern.proxy.staticproxy;

public interface ITeacherDao {
    void teach(); // 授课方法
}
```

```java
package com.pattern.proxy.staticproxy;

// 被代理对象
public class TeacherDao implements ITeacherDao{
    @Override
    public void teach() {
        System.out.println("教师授课ing。。。");
    }
}
```

```java
package com.pattern.proxy.staticproxy;
// 静态代理
// 代理对象，通过代理对象拓展被代理对象(目标对象)的功能
public class TeacherDaoProxy implements ITeacherDao{

    private ITeacherDao target; // 目标对象，通过接口来聚合

    public TeacherDaoProxy(ITeacherDao iTeacherDao) {
        super();
        this.target = iTeacherDao;
    }

    @Override
    public void teach() {
        System.out.println("开始代理，代理对象增加功能：打开投影仪，连接电脑，打开ppt。。。");
        target.teach();
        System.out.println("|提交|");
    }
}
```

```java
package com.pattern.proxy.staticproxy;

public class Client {
    public static void main(String[] args) {
        // 创建目标对象
        TeacherDao teacherDao = new TeacherDao();
        // 创建代理对象，同时将被代理对象传递给代理对象（聚合）
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);
        // 通过代理对象，调用被代理对象的方法,即执行的是代理对象的方法，代理对象中会调用目标对象的方法
        teacherDaoProxy.teach();
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112181539167.png" alt="image-20211218153943089" style="zoom:80%;" />

动态代理(JDK代理)：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112181542484.png" alt="image-20211218154201410" style="zoom:80%;" />

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112181545231.png" alt="image-20211218154534170" style="zoom:80%;" />

getProxyInstance()：利用反射机制，返回一个代理对象

```java
package com.pattern.proxy.dynamicproxy;
// 接口
public interface ITeacherDao {
    void teach(); // 授课方法
    void sayHello(String name);
}
```

```java
package com.pattern.proxy.dynamicproxy;

// 这是被代理对象，也就是 目标对象
public class TeacherDao implements ITeacherDao{
    @Override
    public void teach() {
        System.out.println("教师授课中ing。。。");
    }

    @Override
    public void sayHello(String name) {
        System.out.println("Hello " + name);
    }
}
```

```java
package com.pattern.proxy.dynamicproxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory {
    // 维护一个目标对象，Object
    private Object target;

    // 构造器
    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 给目标对象生成一个代理对象
    public Object getProxyInstance() {
        /*
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
         1.ClassLoader loader：指定当前目标对象使用的类加载器，获取加载器的方法固定
         2.Class<?>[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型
         3.InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器方法，会把目标对象的方法作为参数传入
         */
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {  // 创建匿名子类对象
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("JD代理开始。。。");
                        // 通过反射机制调用目标对象的方法，target是被代理的目标对象，args是目标对象方法的参数
                        Object returnVal = method.invoke(target, args);
                        System.out.println("JDK代理提交。。。");
                        return returnVal;
                    }
                });

    }
}
```

```java
package com.pattern.proxy.dynamicproxy;

public class Client {
    public static void main(String[] args) {
        ITeacherDao target = new TeacherDao();
        // 为目标对象创建代理对象，可以转成ITeacherDao
        ITeacherDao proxyInstance = (ITeacherDao) new ProxyFactory(target).getProxyInstance();
        // 返回 proxyInstance=class com.sun.proxy.$Proxy0
        // 可以看出，内存中动态生成了代理对象，有$符号表示这是一个代理对象
        System.out.println("proxyInstance=" + proxyInstance.getClass());
        // 通过代理对象，调用目标对象方法
        proxyInstance.teach();

        proxyInstance.sayHello("Jerry!!");
    }
}
```

cglib：

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112181700293.png" alt="image-20211218170055182" style="zoom:80%;" />

![image-20211218203607756](https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112182036849.png)

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112182039835.png" alt="image-20211218203940769" style="zoom:80%;" />

```java
package com.pattern.proxy.cglibproxy;

public class TeacherDao {
    public  String teach() {
        System.out.println("教师授课中，我是cglib代理，目标对象不需要实现接口");
        return "TeacherDao return";
    }
}
```

```java
package com.pattern.proxy.cglibproxy;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

// 导入包asm-9.2.jar，asm-commons-9.2.jar，asm-tree-9.2.jar，cglib-3.3.0.jar
public class ProxyFactory implements MethodInterceptor {
    // 聚合一个目标对象
    private Object target;
    // 构造器，传入一个被代理的对象
    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 返回一个代理对象，是 target 的代理对象
    public Object getProxyInstance() {
        // 1.创建一个工具类
        Enhancer enhancer = new Enhancer();
        // 2.设置父类
        enhancer.setSuperclass(target.getClass());
        // 3.设置回调函数
        enhancer.setCallback(this);
        // 4.创建子类对象，即代理对象
        return enhancer.create();
    }

    // 重写 intercept 方法，调用目标对象的方法
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("== cglib代理模式开始 ==");
        Object returnVal = method.invoke(target, args); // 调用目标对象方法，并接收返回值
        System.out.println("== cglib代理提交 ==");
        return returnVal;
    }
}
```

```java
package com.pattern.proxy.cglibproxy;

public class Client {
    public static void main(String[] args) {
        // 创建目标对象
        TeacherDao target = new TeacherDao();
        // 获取代理对象，并将目标对象传过去
        TeacherDao proxyFactory = (TeacherDao) new ProxyFactory(target).getProxyInstance();

        // 执行代理对象的方法，触发intercept方法，从而实现对目标对象的方法调用
        String result = proxyFactory.teach();
        System.out.println(result);
    }
}
```

<img src="https://gitee.com/wang-xiangtai11/typora-figure/raw/master/img/202112182111743.png" alt="image-20211218210729880" style="zoom:80%;" />





